package tools;
using StringTools;
import tools.Dictionary;
import tools.StringBuilder;

/**
 * SfGmx offers tools for parsing and printing GameMaker's XML-based GMX files.
 * Indentation and formatting rules are kept binary identical.
 * @author YellowAfterlife@sfgml
 */
class SfGmx {
	//
	public var name:String;
	public var text:String;
	public var textAsFloat(get, never):Float;
	private inline function get_textAsFloat():Float {
		return Std.parseFloat(text);
	}
	public var textAsInt(get, never):Int;
	private inline function get_textAsInt():Int {
		return Std.parseInt(text);
	}
	//
	public var children:Array<SfGmx> = [];
	private var attrList:Array<String> = [];
	private var attrMap:Dictionary<String> = new Dictionary();
	public function new(name:String, text:String = null) {
		this.name = name;
		this.text = text;
	}
	//
	public inline function addChild(q:SfGmx):Void {
		children.push(q);
	}
	public function addTextChild(name:String, value:String):SfGmx {
		var r = new SfGmx(name, value);
		addChild(r);
		return r;
	}
	public inline function addEmptyChild(name:String):SfGmx {
		return addTextChild(name, null);
	}
	public inline function addBoolChild(name:String, value:Bool):SfGmx {
		return addTextChild(name, value ? "-1" : "0");
	}
	public inline function addIntChild(name:String, value:Int):SfGmx {
		return addTextChild(name, "" + value);
	}
	public inline function addFloatChild(name:String, value:Float):SfGmx {
		return addTextChild(name, "" + value);
	}
	//
	public function insertBefore(newNode:SfGmx, refNode:SfGmx) {
		var pos = children.indexOf(refNode);
		if (pos >= 0) {
			children.insert(pos, newNode);
		} else children.push(newNode);
	}
	//
	public inline function removeChild(q:SfGmx):Void {
		children.remove(q);
	}
	public inline function clearChildren():Void {
		children.splice(0, children.length);
	}
	//
	/** Finds the first element with given name */
	public function find(name:String):SfGmx {
		for (q in children) if (q.name == name) return q;
		return null;
	}
	/** Finds the first element with given name and returns it's text, otherwise returns null */
	public function findText(name:String):String {
		for (q in children) if (q.name == name) return q.text;
		return null;
	}
	/** Finds the first element with given name and returns it's text, otherwise returns null */
	public function findInt(name:String):Null<Int> {
		for (q in children) if (q.name == name) return q.textAsInt;
		return null;
	}
	/** Finds the first element with given name and returns it's text, otherwise returns null */
	public function findFloat(name:String):Null<Float> {
		for (q in children) if (q.name == name) return q.textAsFloat;
		return null;
	}
	/** Finds all elements with given name */
	public function findAll(name:String):Array<SfGmx> {
		var r = [];
		for (q in children) if (q.name == name) r.push(q);
		return r;
	}
	/** Finds all elements with given name, including in child nodes */
	public function findRec(name:String, ?r:Array<SfGmx>):Array<SfGmx> {
		if (r == null) r = [];
		for (q in children) {
			if (q.name == name) r.push(q);
			q.findRec(name, r);
		}
		return r;
	}
	//
	public inline function get(attr:String):String {
		return attrMap[attr];
	}
	public function set(attr:String, value:String):Void {
		if (!attrMap.exists(attr)) attrList.push(attr);
		attrMap.set(attr, value);
	}
	public inline function setInt(attr:String, value:Int):Void {
		set(attr, "" + value);
	}
	public inline function exists(attr:String):Bool {
		return attrMap.exists(attr);
	}
	public function remove(attr:String):Bool {
		if (attrMap.exists(attr)) {
			attrMap.remove(attr);
			attrList.remove(attr);
			return true;
		} else return false;
	}
	public inline function keys():Array<String> {
		return attrList.copy();
	}
	//
	private function toStringRec(r:StringBuilder, t:String) {
		r.addChar("<".code);
		r.addString(name);
		for (attr in attrList) {
			r.addFormat(' %s="%s"', attr, attrMap[attr].htmlEscape(true));
		}
		if (children.length == 0 && text == null) {
			r.addString("/>");
			return;
		}
		r.addChar(">".code);
		var n = children.length;
		if (n > 0) {
			var t1 = t + "  ";
			for (i in 0 ... n) {
				r.add("\r\n");
				r.add(t1);
				children[i].toStringRec(r, t1);
			}
			r.add("\r\n");
			r.add(t);
		} else r.add(text.htmlEscape());
		r.addFormat('</%s>', name);
	}
	
	/** */
	@:keep public function toString() {
		var b = new StringBuilder();
		toStringRec(b, "");
		return b.toString();
	}
	
	/** Converts to a string with a GM-specific header, ready to write. */
	public function toGmxString() {
		var b = new StringBuilder();
		b.addString("<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->\r\n");
		toStringRec(b, "");
		b.addString("\r\n");
		return b.toString();
	}
	
	/** Recursively converts a XML node to GMX. */
	public static function fromXml(xml:Xml):SfGmx {
		var gmx = new SfGmx(xml.nodeName);
		for (a in xml.attributes()) {
			gmx.attrList.push(a);
			gmx.attrMap.set(a, xml.get(a));
		}
		for (q in xml.elements()) {
			gmx.children.push(fromXml(q));
		}
		if (gmx.children.length == 0) {
			var q = xml.firstChild();
			if (q != null) gmx.text = q.nodeValue;
		}
		return gmx;
	}
	
	/** Parses from given XML string, returns top-level node (e.g. <project>). */
	public static function parse(code:String) {
		var xml = Xml.parse(code);
		return fromXml(xml.firstElement());
	}
	//
}
